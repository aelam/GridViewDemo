// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SortedList_Request.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "SortedListRequest.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - SortedListRequestRoot

@implementation SortedListRequestRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SortedListRequestRoot_FileDescriptor

static GPBFileDescriptor *SortedListRequestRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - SortedList_Request

@implementation SortedList_Request

@dynamic requestTypeOneOfCase;
@dynamic system;
@dynamic custom;
@dynamic goods;
@dynamic group;
@dynamic fieldsIdArray, fieldsIdArray_Count;
@dynamic hasSortOption, sortOption;
@dynamic beginPosition;
@dynamic limitSize;

typedef struct SortedList_Request__storage_ {
  uint32_t _has_storage_[2];
  uint32_t goods;
  uint32_t beginPosition;
  uint32_t limitSize;
  SortedList_Request_ClassTypeList *system;
  SortedList_Request_GoodsList *custom;
  SortedList_Request_GroupInfo *group;
  GPBInt32Array *fieldsIdArray;
  SortedList_Request_SortOptions *sortOption;
} SortedList_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "system",
        .dataTypeSpecific.className = GPBStringifySymbol(SortedList_Request_ClassTypeList),
        .number = SortedList_Request_FieldNumber_System,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, system),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "custom",
        .dataTypeSpecific.className = GPBStringifySymbol(SortedList_Request_GoodsList),
        .number = SortedList_Request_FieldNumber_Custom,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, custom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goods",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_FieldNumber_Goods,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, goods),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(SortedList_Request_GroupInfo),
        .number = SortedList_Request_FieldNumber_Group,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fieldsIdArray",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_FieldNumber_FieldsIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, fieldsIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sortOption",
        .dataTypeSpecific.className = GPBStringifySymbol(SortedList_Request_SortOptions),
        .number = SortedList_Request_FieldNumber_SortOption,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, sortOption),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "beginPosition",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_FieldNumber_BeginPosition,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, beginPosition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "limitSize",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_FieldNumber_LimitSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SortedList_Request__storage_, limitSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SortedList_Request class]
                                     rootClass:[SortedListRequestRoot class]
                                          file:SortedListRequestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SortedList_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "requestType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SortedList_Request_ClearRequestTypeOneOfCase(SortedList_Request *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - SortedList_Request_ClassTypeList

@implementation SortedList_Request_ClassTypeList

@dynamic exchangeCategoryArray, exchangeCategoryArray_Count;

typedef struct SortedList_Request_ClassTypeList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *exchangeCategoryArray;
} SortedList_Request_ClassTypeList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeCategoryArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SortedList_Request_ClassTypeList_ClassType),
        .number = SortedList_Request_ClassTypeList_FieldNumber_ExchangeCategoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SortedList_Request_ClassTypeList__storage_, exchangeCategoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SortedList_Request_ClassTypeList class]
                                     rootClass:[SortedListRequestRoot class]
                                          file:SortedListRequestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SortedList_Request_ClassTypeList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SortedList_Request)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SortedList_Request_ClassTypeList_ClassType

@implementation SortedList_Request_ClassTypeList_ClassType

@dynamic exchange;
@dynamic category;

typedef struct SortedList_Request_ClassTypeList_ClassType__storage_ {
  uint32_t _has_storage_[1];
  uint32_t exchange;
  uint64_t category;
} SortedList_Request_ClassTypeList_ClassType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchange",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_ClassTypeList_ClassType_FieldNumber_Exchange,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SortedList_Request_ClassTypeList_ClassType__storage_, exchange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_ClassTypeList_ClassType_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SortedList_Request_ClassTypeList_ClassType__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SortedList_Request_ClassTypeList_ClassType class]
                                     rootClass:[SortedListRequestRoot class]
                                          file:SortedListRequestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SortedList_Request_ClassTypeList_ClassType__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SortedList_Request_ClassTypeList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SortedList_Request_GoodsList

@implementation SortedList_Request_GoodsList

@dynamic goodsIdArray, goodsIdArray_Count;

typedef struct SortedList_Request_GoodsList__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *goodsIdArray;
} SortedList_Request_GoodsList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "goodsIdArray",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_GoodsList_FieldNumber_GoodsIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SortedList_Request_GoodsList__storage_, goodsIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SortedList_Request_GoodsList class]
                                     rootClass:[SortedListRequestRoot class]
                                          file:SortedListRequestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SortedList_Request_GoodsList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SortedList_Request)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SortedList_Request_GroupInfo

@implementation SortedList_Request_GroupInfo

@dynamic goodsId;
@dynamic groupType;

typedef struct SortedList_Request_GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t goodsId;
  uint32_t groupType;
} SortedList_Request_GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "goodsId",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_GroupInfo_FieldNumber_GoodsId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SortedList_Request_GroupInfo__storage_, goodsId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "groupType",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_GroupInfo_FieldNumber_GroupType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SortedList_Request_GroupInfo__storage_, groupType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SortedList_Request_GroupInfo class]
                                     rootClass:[SortedListRequestRoot class]
                                          file:SortedListRequestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SortedList_Request_GroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SortedList_Request)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SortedList_Request_SortOptions

@implementation SortedList_Request_SortOptions

@dynamic sortField;
@dynamic sortAsce;

typedef struct SortedList_Request_SortOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t sortField;
} SortedList_Request_SortOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sortField",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_SortOptions_FieldNumber_SortField,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SortedList_Request_SortOptions__storage_, sortField),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sortAsce",
        .dataTypeSpecific.className = NULL,
        .number = SortedList_Request_SortOptions_FieldNumber_SortAsce,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SortedList_Request_SortOptions class]
                                     rootClass:[SortedListRequestRoot class]
                                          file:SortedListRequestRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SortedList_Request_SortOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SortedList_Request)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
